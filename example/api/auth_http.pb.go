// Code generated by protoc-gen-go-echo-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-echo-http v0.7.0
// - protoc                  v3.12.4
// source: auth.proto

package api

import (
	"fmt"
	"log"
	"net/http"
	"runtime/debug"

	"github.com/labstack/echo/v4"
)

// AuthService is a service for authentication.
// @Description AuthService is a service for authentication.
type AuthService interface {
	// ApplyToken returns a token for the given username and password.
	ApplyToken(c echo.Context, req *ApplyTokenRequest) (resp *ApplyTokenResponse, err error)

	mustEmbedUnimplementedAuthService()
}

type UnimplementedAuthService struct{}

// ApplyToken returns a token for the given username and password.
// @Description  ApplyToken returns a token for the given username and password.
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        req body ApplyTokenRequest true "ApplyTokenRequest is a request for ApplyToken."
// @Success      200 {object} ApplyTokenResponse
// @Router       /auth/apply_token [post]
func (s *UnimplementedAuthService) ApplyToken(c echo.Context, req *ApplyTokenRequest) (resp *ApplyTokenResponse, err error) {
	return nil, c.JSON(http.StatusNotImplemented, "/auth/apply_token not implemented")
}

func (s *UnimplementedAuthService) mustEmbedUnimplementedAuthService() {
}

// BindAuthService register http handlers
func BindAuthService(g *echo.Group, s AuthService) *echo.Group {
	genErrorResp := func(c echo.Context, err error) error {
		errMap := map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		}
		return c.JSON(http.StatusOK, map[string]interface{}{
			"err": errMap,
		})
	}

	handlePanic := func(c echo.Context) error {
		if r := recover(); r != nil {
			log.Printf("%v\n%s", r, debug.Stack())
			return genErrorResp(c, fmt.Errorf("%v", r))
		}
		return nil
	}

	group := g.Group("/auth")
	group.POST("/apply_token", func(c echo.Context) error {
		defer handlePanic(c)

		var req ApplyTokenRequest
		if err := c.Bind(&req); err != nil {
			return c.JSON(http.StatusBadRequest, err.Error())
		}

		resp, err := s.ApplyToken(c, &req)
		if err != nil {
			return genErrorResp(c, err)
		}
		if resp == nil {
			return nil
		}
		return c.JSON(http.StatusOK, resp)
	})

	return group
}
